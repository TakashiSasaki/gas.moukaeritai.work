<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    body { font-family: 'Roboto', sans-serif; background-color: #f5f5f5; color: #333; margin: 0; padding: 20px; }
    .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h1 { color: #4285f4; border-bottom: 2px solid #eee; padding-bottom: 10px; }
    .drop-zone { margin-top: 20px; border: 2px dashed #ccc; padding: 30px; text-align: center; color: #666; transition: background-color 0.2s, border-color 0.2s; }
    .drop-zone.drag-over { background-color: #e8f0fe; border-color: #4285f4; border-style: solid; }
    #upload-form { display: flex; align-items: center; gap: 15px; margin-top: 20px; }
    button { border: none; padding: 12px 20px; font-size: 16px; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; }
    #submitButton { background-color: #4285f4; color: white; }
    #clearButton { background-color: #f1f3f4; color: #5f6368; }
    #clearButton:hover { background-color: #e8eaed; }
    button:disabled { background-color: #9e9e9e; color: white; cursor: not-allowed; }
    #status { margin-top: 20px; min-height: 24px; }
    .status-main { font-weight: bold; }
    .summary { font-size: 0.9em; color: #5f6368; margin-top: 8px; font-weight: normal; }
    b { color: #202124; }
    .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #4285f4; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block; vertical-align: middle; margin-right: 10px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    #result-container { margin-top: 20px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 12px; border-bottom: 1px solid #ddd; word-break: break-all; }
    th { background-color: #f2f2f2; }
    tr:hover { background-color: #f9f9f9; }
    .error { color: #d93025; font-weight: bold; }
    #export-controls { margin-top: 25px; padding-top: 15px; border-top: 1px solid #eee; display: flex; flex-wrap: wrap; gap: 15px; }
    .export-button { background-color: #fff; color: #4285f4; border: 1px solid #ddd; font-size: 14px; padding: 8px 16px; }
    .export-button:hover { background-color: #f8f9fa; }
    #saveToSheetButton { background-color: #1e8e3e; color: white; border: none; }
    #saveToSheetButton:hover { background-color: #188038; }
  </style>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
</head>
<body>
  <div class="container">
    <h1>DNS Record Extractor</h1>
    <p>DNS settings screenshots (PNG, JPG) – select, drag & drop, or paste. You can process multiple files simultaneously.</p>

    <div id="dropZone" class="drop-zone">
      <input type="file" id="imageFile" accept="image/png, image/jpeg, image/webp" multiple>
      <p>Or drag & drop files here</p>
    </div>

    <div id="upload-form">
      <button id="submitButton">Extract</button>
      <button id="clearButton" type="button">Clear Results</button>
    </div>

    <div id="status"></div>
    <div id="result-container"></div>
    
    <div id="export-controls" style="display: none;">
      <button id="downloadCsvButton" class="export-button">Download CSV</button>
      <button id="downloadJsonButton" class="export-button">Download JSON</button>
      <button id="saveToSheetButton" class="export-button">Save to Google Sheet</button>
    </div>

  </div>

  <script>
    // Global state: store all unique DNS records
    let allRecords = [];

    // Element selectors
    const submitButton = document.getElementById('submitButton');
    const clearButton = document.getElementById('clearButton');
    const imageFile = document.getElementById('imageFile');
    const statusDiv = document.getElementById('status');
    const resultContainer = document.getElementById('result-container');
    const dropZone = document.getElementById('dropZone');
    const exportControls = document.getElementById('export-controls');
    const downloadCsvButton = document.getElementById('downloadCsvButton');
    const downloadJsonButton = document.getElementById('downloadJsonButton');
    const saveToSheetButton = document.getElementById('saveToSheetButton');

    // Event listeners
    submitButton.addEventListener('click', handleButtonClick);
    clearButton.addEventListener('click', handleClearClick);
    imageFile.addEventListener('change', handleFileSelect);
    document.addEventListener('paste', handlePaste, false);
    downloadCsvButton.addEventListener('click', downloadAsCsv);
    downloadJsonButton.addEventListener('click', downloadAsJson);
    saveToSheetButton.addEventListener('click', saveToSheet);
    
    // Drag & Drop events
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false);
    });
    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false);
    });
    dropZone.addEventListener('drop', handleDrop, false);
    
    function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

    function handleButtonClick() {
      processFiles(imageFile.files);
    }

    function handleFileSelect(e) {
      const files = e.target.files;
      statusDiv.innerHTML = `<div class="status-main">${files.length} file(s) selected.</div>`;
    }

    function handleDrop(e) {
      const files = e.dataTransfer.files;
      imageFile.files = files;
      processFiles(files);
    }

    function handlePaste(e) {
      const files = [];
      const items = (e.clipboardData || e.originalEvent.clipboardData).items;
      for (const item of items) {
        if (item.kind === 'file' && item.type.startsWith('image/')) {
          files.push(item.getAsFile());
        }
      }
      if (files.length > 0) {
        const dt = new DataTransfer();
        files.forEach(f => dt.items.add(f));
        imageFile.files = dt.files;
        statusDiv.innerHTML = `<div class="status-main">Pasted ${files.length} image(s).</div>`;
        processFiles(files);
      }
    }

    function handleClearClick() {
      allRecords = [];
      resultContainer.innerHTML = '';
      statusDiv.innerHTML = '<div class="status-main">Results cleared.</div>';
      imageFile.value = '';
      updateExportButtons();
      setTimeout(() => {
        if (statusDiv.textContent === 'Results cleared.') {
          statusDiv.innerHTML = '';
        }
      }, 3000);
    }

    function processFiles(fileList) {
      if (!fileList || fileList.length === 0) {
        displayError({ message: 'No files selected.' });
        return;
      }
      const validTypes = ['image/png', 'image/jpeg', 'image/webp'];
      for (const file of fileList) {
        if (!validTypes.includes(file.type)) {
          displayError({ message: `Invalid file type: ${file.name}` });
          return;
        }
      }
      setLoading(true, `Loading files... (1/${fileList.length})`);
      const readers = Array.from(fileList).map(file => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = () => resolve({ base64: reader.result, mimeType: file.type, name: file.name });
          reader.onerror = err => reject(err);
        });
      });
      Promise.all(readers)
        .then(data => {
          setLoading(true, `Processing ${data.length} image(s) on server...`);
          const bases = data.map(d => d.base64);
          const mimes = data.map(d => d.mimeType);
          const names = data.map(d => d.name);
          google.script.run
            .withSuccessHandler(displayResults)
            .withFailureHandler(displayError)
            .extractDnsRecordsFromImages(bases, mimes, names);
        })
        .catch(() => displayError({ message: 'Failed to read files.' }));
    }

    function displayResults(jsonString) {
      setLoading(false);
      try {
        const newRecs = JSON.parse(jsonString);
        if (!Array.isArray(newRecs)) throw new Error('Invalid data format.');
        const existing = new Set(allRecords.map(r => `${r.type}|${r.hostname}|${r.value}`));
        let added = 0;
        newRecs.forEach(r => {
          const key = `${r.type}|${r.hostname}|${r.value}`;
          if (!existing.has(key)) {
            allRecords.push(r);
            existing.add(key);
            added++;
          }
        });
        if (allRecords.length === 0) {
          statusDiv.innerHTML = '<div class="status-main">No DNS records found.</div>';
          updateExportButtons();
          return;
        }
        const msg = added === 0
          ? `No new unique records. Total records: ${allRecords.length}.`
          : `${added} new record(s) added. Total records: ${allRecords.length}.`;
        statusDiv.innerHTML = `<div class="status-main">${msg}</div>`;
        const counts = allRecords.reduce((a, r) => {
          a[r.type] = (a[r.type] || 0) + 1;
          return a;
        }, {});
        const summary = Object.keys(counts)
          .sort()
          .map(t => `<b>${t}</b>: ${counts[t]}`)
          .join(' | ');
        statusDiv.innerHTML += `<div class="summary">${summary}</div>`;

        createTable(allRecords);
        updateExportButtons();
      } catch (e) {
        displayError({ message: 'Failed to parse server response.' });
        console.error(e);
      }
    }

    function createTable(records) {
      const headers = ['type', 'hostname', 'value', 'ttl', 'priority'];
      // Define desired RR type order
      const typeOrder = ['NS','A','AAAA','CNAME','MX','TXT','SRV','DS','CAA'];

      // Sort by type order first, then by hostname, then by type alphabetically
      records.sort((a, b) => {
        const ta = typeOrder.indexOf(a.type.toUpperCase());
        const tb = typeOrder.indexOf(b.type.toUpperCase());
        // If one of the types is recognized, use that ordering
        if (ta !== -1 || tb !== -1) {
          if (ta === -1) return 1;           // unrecognized types go last
          if (tb === -1) return -1;
          if (ta !== tb) return ta - tb;
        }
        // Fallback: sort by hostname, then by type name
        return a.hostname.localeCompare(b.hostname)
            || a.type.localeCompare(b.type);
      });

      // Build table HTML
      let html = '<table><thead><tr>';
      headers.forEach(h => { html += `<th>${h.toUpperCase()}</th>`; });
      html += '</tr></thead><tbody>';
      records.forEach(rec => {
        html += '<tr>';
        headers.forEach(h => {
          const val = rec[h] != null ? rec[h] : '–';
          html += `<td>${escapeHtml(String(val))}</td>`;
        });
        html += '</tr>';
      });
      html += '</tbody></table>';
      resultContainer.innerHTML = html;
    }

    function updateExportButtons() {
      exportControls.style.display = allRecords.length > 0 ? 'flex' : 'none';
    }

    function displayError(error) {
      setLoading(false);
      statusDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
    }

    function setLoading(isLoading, message = '') {
      submitButton.disabled = isLoading;
      clearButton.disabled = isLoading;
      statusDiv.innerHTML = isLoading
        ? `<div class="spinner"></div> ${message}`
        : statusDiv.innerHTML;
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.appendChild(document.createTextNode(str));
      return div.innerHTML;
    }

    function downloadAsJson() {
      if (!allRecords.length) return;
      const blob = new Blob([JSON.stringify(allRecords, null, 2)], { type: 'application/json' });
      triggerDownload(blob, 'dns_records.json');
    }

    function downloadAsCsv() {
      if (!allRecords.length) return;
      const headers = ['type', 'hostname', 'value', 'ttl', 'priority'];
      let csv = headers.join(',') + '\n';
      allRecords.forEach(rec => {
        const row = headers.map(h => {
          let cell = rec[h] != null ? String(rec[h]) : '';
          cell = cell.replace(/"/g, '""');
          if (cell.includes(',')) cell = `"${cell}"`;
          return cell;
        }).join(',');
        csv += row + '\n';
      });
      const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
      triggerDownload(blob, 'dns_records.csv');
    }

    function triggerDownload(blob, fileName) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function saveToSheet() {
      if (!allRecords.length) return;
      setLoading(true, 'Saving to Google Sheet...');
      google.script.run
        .withSuccessHandler(onSaveSuccess)
        .withFailureHandler(onSaveFailure)
        .saveRecordsToSheet(allRecords);
    }

    function onSaveSuccess(url) {
      setLoading(false);
      statusDiv.innerHTML += `<div class="status-main" style="color:#1e8e3e; margin-top:10px;">Saved to sheet. <a href="${url}" target="_blank">Open</a></div>`;
    }

    function onSaveFailure(error) {
      statusDiv.innerHTML += `<div class="error" style="margin-top:10px;">Save failed: ${error.message}</div>`;
      setLoading(false);
    }
  </script>
</body>
</html>
